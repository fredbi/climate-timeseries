/**
 * Climate time series API
 * The API allows the public to search and consult time series about climate change research conducted by TheShiftProject.  The climate time series API allows contributors to upload time series about their climate change models and studies.  Other secured endpoints allows admins to maintain the nomenclatures used by the climate time series, such as units etc. Timeseries publication status and ownership is for now managed by admins. 
 *
 * OpenAPI spec version: v0.0.1
 * Contact: fredbi@yahoo.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.example.com/v1/';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class ApiError {
    'code'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiError.attributeTypeMap;
    }
}

export class Audit {
    'createdAt'?: Date;
    'createdBy'?: string;
    'lastUpdatedAt'?: Date;
    'lastUpdatedBy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "createdBy",
            "baseName": "createdBy",
            "type": "string"
        },
        {
            "name": "lastUpdatedAt",
            "baseName": "lastUpdatedAt",
            "type": "Date"
        },
        {
            "name": "lastUpdatedBy",
            "baseName": "lastUpdatedBy",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Audit.attributeTypeMap;
    }
}

/**
* Metadata about nomenture classes. 
*/
export class ClassDescription {
    '_class': ClassNomenclatureName;
    'tableName': string;
    'title': Translation;
    'descriptionShort': Translation;
    'descriptionLong': Translation;
    'metadata': ClassMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_class",
            "baseName": "class",
            "type": "ClassNomenclatureName"
        },
        {
            "name": "tableName",
            "baseName": "tableName",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "Translation"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "Translation"
        },
        {
            "name": "descriptionLong",
            "baseName": "descriptionLong",
            "type": "Translation"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ClassMetadata"
        }    ];

    static getAttributeTypeMap() {
        return ClassDescription.attributeTypeMap;
    }
}

/**
* Metadata used by UIs to render classes. 
*/
export class ClassMetadata {
    'fromTemplate'?: boolean;
    'tagSearch'?: boolean;
    'extraFields'?: Array<string>;
    'hasOneClass'?: { [key: string]: string; };
    'hasZeroOneClass'?: { [key: string]: string; };
    'hasZeroManyClass'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fromTemplate",
            "baseName": "fromTemplate",
            "type": "boolean"
        },
        {
            "name": "tagSearch",
            "baseName": "tagSearch",
            "type": "boolean"
        },
        {
            "name": "extraFields",
            "baseName": "extraFields",
            "type": "Array<string>"
        },
        {
            "name": "hasOneClass",
            "baseName": "hasOneClass",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "hasZeroOneClass",
            "baseName": "hasZeroOneClass",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "hasZeroManyClass",
            "baseName": "hasZeroManyClass",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return ClassMetadata.attributeTypeMap;
    }
}

export class ClassNomenclature {
    'id': number;
    'shortCode': ClassNomenclatureName;
    'title': Translation;
    'descriptionShort'?: Translation;
    'descriptionLong'?: Translation;
    'auditTrail'?: Audit;

    static discriminator: string | undefined = "shortCode";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "shortCode",
            "baseName": "shortCode",
            "type": "ClassNomenclatureName"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "Translation"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "Translation"
        },
        {
            "name": "descriptionLong",
            "baseName": "descriptionLong",
            "type": "Translation"
        },
        {
            "name": "auditTrail",
            "baseName": "auditTrail",
            "type": "Audit"
        }    ];

    static getAttributeTypeMap() {
        return ClassNomenclature.attributeTypeMap;
    }
}

export class ClassNomenclatureName {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ClassNomenclatureName.attributeTypeMap;
    }
}

/**
* A composite measurement unit is built from base units with a formula. TODO doc. 
*/
export class CompositeUnit {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CompositeUnit.attributeTypeMap;
    }
}

/**
* Mathematical and physical constants. 
*/
export class Constant extends ClassNomenclature {
    'symbol': string;
    'value': number;
    'metadata': Mumeta;
    'measurementUnit'?: Munit;
    'constantHasMeasurementDomains'?: Array<Mdomain>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "symbol",
            "baseName": "symbol",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Mumeta"
        },
        {
            "name": "measurementUnit",
            "baseName": "measurementUnit",
            "type": "Munit"
        },
        {
            "name": "constantHasMeasurementDomains",
            "baseName": "constantHasMeasurementDomains",
            "type": "Array<Mdomain>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Constant.attributeTypeMap);
    }
}

/**
* Unit conversions. 
*/
export class Conversion {
    'toUnitCode': string;
    'factor'?: number;
    'intercept'?: number;
    'formula'?: string;
    'reverseFormula'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "toUnitCode",
            "baseName": "toUnitCode",
            "type": "string"
        },
        {
            "name": "factor",
            "baseName": "factor",
            "type": "number"
        },
        {
            "name": "intercept",
            "baseName": "intercept",
            "type": "number"
        },
        {
            "name": "formula",
            "baseName": "formula",
            "type": "string"
        },
        {
            "name": "reverseFormula",
            "baseName": "reverse_formula",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Conversion.attributeTypeMap;
    }
}

/**
* Unit conversion specification. 
*/
export class ConversionSpec {
    'toUnitCode': string;
    'factor'?: number;
    'intercept'?: number;
    'formula'?: string;
    'reverseFormula'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "toUnitCode",
            "baseName": "toUnitCode",
            "type": "string"
        },
        {
            "name": "factor",
            "baseName": "factor",
            "type": "number"
        },
        {
            "name": "intercept",
            "baseName": "intercept",
            "type": "number"
        },
        {
            "name": "formula",
            "baseName": "formula",
            "type": "string"
        },
        {
            "name": "reverseFormula",
            "baseName": "reverse_formula",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConversionSpec.attributeTypeMap;
    }
}

export class Document {
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Document.attributeTypeMap;
    }
}

export class Documents extends Array<Document> {

    static discriminator: string | undefined = undefined;

}

export class Entities extends Array<any> {

    static discriminator: string | undefined = undefined;

}

/**
* reserved for future use
*/
export class Extra {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Extra.attributeTypeMap;
    }
}

/**
* A geojson geometry. 
*/
export class Geometry {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Geometry.attributeTypeMap;
    }
}

/**
* Measurement dimensions list the 7 fundamental physical measures, plus money for economics.  For more, see https://en.wikipedia.org/wiki/SI_base_unit. 
*/
export class Mdimension extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Mdimension.attributeTypeMap);
    }
}

/**
* Measurement domains: this is a domain in which a kind of measurement applies.  Examples:   Measuring speed is useful in aeronautics and mechanics, but not so much in construction.    Torque is used in mechanics but not so much in chemistry.  Domains also apply to constants. 
*/
export class Mdomain extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Mdomain.attributeTypeMap);
    }
}

/**
* A measurement refers to any physical or economic measurement, the unit notwithstanding.  Examples:   * speed   * temperature  We introduce \"quantity\" to take into account measurement that count things, as well as \"currency\" to take into account measurements of economic facts.  Measurements usually refer to one or several physical (or economic) dimensions.  Example:   speed is homogeneous to \"L^T-1\"  However, some measurements are without dimension, such as \"QUANTITY\" and \"ANGLE\".  Series of ratios (e.g. % increase of GDP) are not considered measurements. They shall use special units which do not refer to measurements. 
*/
export class Measurement extends ClassNomenclature {
    'dimensions'?: string;
    'measurementHasMeasurementDomains'?: Array<Mdomain>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dimensions",
            "baseName": "dimensions",
            "type": "string"
        },
        {
            "name": "measurementHasMeasurementDomains",
            "baseName": "measurementHasMeasurementDomains",
            "type": "Array<Mdomain>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Measurement.attributeTypeMap);
    }
}

/**
* Multipliers using to prefix measurement units (e.g. m,c,d,da,h,k,M,G...). 
*/
export class Multiplier extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Multiplier.attributeTypeMap);
    }
}

/**
* Measurement units metadata, for rendering (symbol glyphs, aliases...) 
*/
export class Mumeta {
    'extra'?: Extra;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "extra",
            "baseName": "extra",
            "type": "Extra"
        }    ];

    static getAttributeTypeMap() {
        return Mumeta.attributeTypeMap;
    }
}

/**
* Measurement units are used to quantify values provided by time series. 
*/
export class Munit extends ClassNomenclature {
    'isStandard': boolean;
    'includedMultiplier'?: Multiplier;
    'unitMeasurement'?: Measurement;
    'unitMeasurementSystem'?: Musystem;
    'metadata'?: Mumeta;
    'measurementUnitHasConversions'?: Array<ConversionSpec>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isStandard",
            "baseName": "isStandard",
            "type": "boolean"
        },
        {
            "name": "includedMultiplier",
            "baseName": "includedMultiplier",
            "type": "Multiplier"
        },
        {
            "name": "unitMeasurement",
            "baseName": "unitMeasurement",
            "type": "Measurement"
        },
        {
            "name": "unitMeasurementSystem",
            "baseName": "unitMeasurementSystem",
            "type": "Musystem"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Mumeta"
        },
        {
            "name": "measurementUnitHasConversions",
            "baseName": "measurementUnitHasConversions",
            "type": "Array<ConversionSpec>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Munit.attributeTypeMap);
    }
}

/**
* Measurement unit systems. 
*/
export class Musystem extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Musystem.attributeTypeMap);
    }
}

/**
* Status of owners. 
*/
export class Ostatus extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Ostatus.attributeTypeMap);
    }
}

/**
* Owners are the maintainers of timeseries and nomenclatures. 
*/
export class Owner extends ClassNomenclature {
    'uuid': string;
    'name': string;
    'email': string;
    'ownerStatus': Ostatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "ownerStatus",
            "baseName": "ownerStatus",
            "type": "Ostatus"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Owner.attributeTypeMap);
    }
}

/**
* A period describe the periodicity of a time series, e.g. quarterly, yearly, ... 
*/
export class Period extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Period.attributeTypeMap);
    }
}

/**
* Roles qualify how owners contribute to this or that piece of data. 
*/
export class Role extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Role.attributeTypeMap);
    }
}

export class SearchTags extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class Semver {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Semver.attributeTypeMap;
    }
}

/**
* A time series.  The brief description omits descriptionLong, statusChangeReason, tags, linkedDocuments and auditTrail.  The field auditTrail is read-only and requires the \"audit\" query parameter to be retrieved.  The field seriesHasVersions requires the \"deep\" query parameter to be retrieved. 
*/
export class Series {
    'id': number;
    'title': Translation;
    'descriptionShort'?: Translation;
    'descriptionLong'?: Translation;
    'timePeriod': Period;
    'measurementUnit': Munit;
    'inputComposedUnit'?: CompositeUnit;
    'status': Vstatus;
    'statusChangeReason'?: Translation;
    'zone': Zone;
    'dataSource': Source;
    'tags'?: SearchTags;
    'linkedDocuments'?: Documents;
    'auditTrail'?: Audit;
    'seriesHasThemes'?: Array<Theme>;
    'seriesHasOwners'?: Array<Owner>;
    'seriesHasVersions'?: Array<VersionedSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "Translation"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "Translation"
        },
        {
            "name": "descriptionLong",
            "baseName": "descriptionLong",
            "type": "Translation"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "Period"
        },
        {
            "name": "measurementUnit",
            "baseName": "measurementUnit",
            "type": "Munit"
        },
        {
            "name": "inputComposedUnit",
            "baseName": "inputComposedUnit",
            "type": "CompositeUnit"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Vstatus"
        },
        {
            "name": "statusChangeReason",
            "baseName": "statusChangeReason",
            "type": "Translation"
        },
        {
            "name": "zone",
            "baseName": "zone",
            "type": "Zone"
        },
        {
            "name": "dataSource",
            "baseName": "dataSource",
            "type": "Source"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "SearchTags"
        },
        {
            "name": "linkedDocuments",
            "baseName": "linkedDocuments",
            "type": "Documents"
        },
        {
            "name": "auditTrail",
            "baseName": "auditTrail",
            "type": "Audit"
        },
        {
            "name": "seriesHasThemes",
            "baseName": "seriesHasThemes",
            "type": "Array<Theme>"
        },
        {
            "name": "seriesHasOwners",
            "baseName": "seriesHasOwners",
            "type": "Array<Owner>"
        },
        {
            "name": "seriesHasVersions",
            "baseName": "seriesHasVersions",
            "type": "Array<VersionedSeries>"
        }    ];

    static getAttributeTypeMap() {
        return Series.attributeTypeMap;
    }
}

/**
* Data sources. 
*/
export class Source extends ClassNomenclature {
    'rating'?: number;
    'tags'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rating",
            "baseName": "rating",
            "type": "number"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Source.attributeTypeMap);
    }
}

/**
* Object statuses. 
*/
export class Status extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Status.attributeTypeMap);
    }
}

/**
* Climate themes. 
*/
export class Theme extends ClassNomenclature {
    'tags'?: Array<string>;
    'linkedDocuments'?: Documents;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "linkedDocuments",
            "baseName": "linkedDocuments",
            "type": "Documents"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Theme.attributeTypeMap);
    }
}

/**
* Metadata about nomenture classes. 
*/
export class TimeseriesModelsYamldefinitionsclassDescription {
    '_class': ClassNomenclatureName;
    'tableName': string;
    'title': Translation;
    'descriptionShort': Translation;
    'descriptionLong': Translation;
    'metadata': ClassMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_class",
            "baseName": "class",
            "type": "ClassNomenclatureName"
        },
        {
            "name": "tableName",
            "baseName": "tableName",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "Translation"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "Translation"
        },
        {
            "name": "descriptionLong",
            "baseName": "descriptionLong",
            "type": "Translation"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ClassMetadata"
        }    ];

    static getAttributeTypeMap() {
        return TimeseriesModelsYamldefinitionsclassDescription.attributeTypeMap;
    }
}

export class TimeseriesModelsYamldefinitionsclassNomenclature {
    'id': number;
    'shortCode': ClassNomenclatureName;
    'title': Translation;
    'descriptionShort'?: Translation;
    'descriptionLong'?: Translation;
    'auditTrail'?: Audit;

    static discriminator: string | undefined = "shortCode";

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "shortCode",
            "baseName": "shortCode",
            "type": "ClassNomenclatureName"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "Translation"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "Translation"
        },
        {
            "name": "descriptionLong",
            "baseName": "descriptionLong",
            "type": "Translation"
        },
        {
            "name": "auditTrail",
            "baseName": "auditTrail",
            "type": "Audit"
        }    ];

    static getAttributeTypeMap() {
        return TimeseriesModelsYamldefinitionsclassNomenclature.attributeTypeMap;
    }
}

/**
* Unit conversion specification. 
*/
export class TimeseriesModelsYamldefinitionsconversionSpec {
    'toUnitCode': string;
    'factor'?: number;
    'intercept'?: number;
    'formula'?: string;
    'reverseFormula'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "toUnitCode",
            "baseName": "toUnitCode",
            "type": "string"
        },
        {
            "name": "factor",
            "baseName": "factor",
            "type": "number"
        },
        {
            "name": "intercept",
            "baseName": "intercept",
            "type": "number"
        },
        {
            "name": "formula",
            "baseName": "formula",
            "type": "string"
        },
        {
            "name": "reverseFormula",
            "baseName": "reverse_formula",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TimeseriesModelsYamldefinitionsconversionSpec.attributeTypeMap;
    }
}

/**
* A time series.  The brief description omits descriptionLong, statusChangeReason, tags, linkedDocuments and auditTrail.  The field auditTrail is read-only and requires the \"audit\" query parameter to be retrieved.  The field seriesHasVersions requires the \"deep\" query parameter to be retrieved. 
*/
export class TimeseriesModelsYamldefinitionsseries {
    'id': number;
    'title': Translation;
    'descriptionShort'?: Translation;
    'descriptionLong'?: Translation;
    'timePeriod': Period;
    'measurementUnit': Munit;
    'inputComposedUnit'?: CompositeUnit;
    'status': Vstatus;
    'statusChangeReason'?: Translation;
    'zone': Zone;
    'dataSource': Source;
    'tags'?: SearchTags;
    'linkedDocuments'?: Documents;
    'auditTrail'?: Audit;
    'seriesHasThemes'?: Array<Theme>;
    'seriesHasOwners'?: Array<Owner>;
    'seriesHasVersions'?: Array<VersionedSeries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "Translation"
        },
        {
            "name": "descriptionShort",
            "baseName": "descriptionShort",
            "type": "Translation"
        },
        {
            "name": "descriptionLong",
            "baseName": "descriptionLong",
            "type": "Translation"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "Period"
        },
        {
            "name": "measurementUnit",
            "baseName": "measurementUnit",
            "type": "Munit"
        },
        {
            "name": "inputComposedUnit",
            "baseName": "inputComposedUnit",
            "type": "CompositeUnit"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Vstatus"
        },
        {
            "name": "statusChangeReason",
            "baseName": "statusChangeReason",
            "type": "Translation"
        },
        {
            "name": "zone",
            "baseName": "zone",
            "type": "Zone"
        },
        {
            "name": "dataSource",
            "baseName": "dataSource",
            "type": "Source"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "SearchTags"
        },
        {
            "name": "linkedDocuments",
            "baseName": "linkedDocuments",
            "type": "Documents"
        },
        {
            "name": "auditTrail",
            "baseName": "auditTrail",
            "type": "Audit"
        },
        {
            "name": "seriesHasThemes",
            "baseName": "seriesHasThemes",
            "type": "Array<Theme>"
        },
        {
            "name": "seriesHasOwners",
            "baseName": "seriesHasOwners",
            "type": "Array<Owner>"
        },
        {
            "name": "seriesHasVersions",
            "baseName": "seriesHasVersions",
            "type": "Array<VersionedSeries>"
        }    ];

    static getAttributeTypeMap() {
        return TimeseriesModelsYamldefinitionsseries.attributeTypeMap;
    }
}

export class TimeseriesModelsYamldefinitionstsValues extends Array<TsValue> {

    static discriminator: string | undefined = undefined;

}

/**
* A version of a time series.  The brief description omits versionDescriptionLong, versionStatusChangeReason, tags, linkedDocuments and auditTrail.  The field auditTrail is read-only and requires the \"audit\" query parameter to be retrieved.  The field timeseries requires the \"deep\" query parameter to be retrieved. 
*/
export class TimeseriesModelsYamldefinitionsversionedSeries {
    'version': Semver;
    'versionedId': string;
    'versionOwner'?: string;
    'versionStatus': Vstatus;
    'parentVersionedId'?: string;
    'formula'?: string;
    'versionStatusChangeReason'?: Translation;
    'versionTitle'?: Translation;
    'versionDescriptionShort'?: Translation;
    'versionDescriptionLong'?: Translation;
    'timeseries'?: TsValues;
    'auditTrail'?: Audit;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "Semver"
        },
        {
            "name": "versionedId",
            "baseName": "versionedId",
            "type": "string"
        },
        {
            "name": "versionOwner",
            "baseName": "versionOwner",
            "type": "string"
        },
        {
            "name": "versionStatus",
            "baseName": "versionStatus",
            "type": "Vstatus"
        },
        {
            "name": "parentVersionedId",
            "baseName": "parentVersionedId",
            "type": "string"
        },
        {
            "name": "formula",
            "baseName": "formula",
            "type": "string"
        },
        {
            "name": "versionStatusChangeReason",
            "baseName": "versionStatusChangeReason",
            "type": "Translation"
        },
        {
            "name": "versionTitle",
            "baseName": "versionTitle",
            "type": "Translation"
        },
        {
            "name": "versionDescriptionShort",
            "baseName": "versionDescriptionShort",
            "type": "Translation"
        },
        {
            "name": "versionDescriptionLong",
            "baseName": "versionDescriptionLong",
            "type": "Translation"
        },
        {
            "name": "timeseries",
            "baseName": "timeseries",
            "type": "TsValues"
        },
        {
            "name": "auditTrail",
            "baseName": "auditTrail",
            "type": "Audit"
        }    ];

    static getAttributeTypeMap() {
        return TimeseriesModelsYamldefinitionsversionedSeries.attributeTypeMap;
    }
}

/**
* Translation is a multi-language string. 
*/
export class Translation extends null<String, string> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Translation.attributeTypeMap);
    }
}

export class Ts {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Ts.attributeTypeMap;
    }
}

export class TsValue {
    't'?: Ts;
    'v'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "t",
            "baseName": "t",
            "type": "Ts"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TsValue.attributeTypeMap;
    }
}

export class TsValues extends Array<TsValue> {

    static discriminator: string | undefined = undefined;

}

/**
* A version of a time series.  The brief description omits versionDescriptionLong, versionStatusChangeReason, tags, linkedDocuments and auditTrail.  The field auditTrail is read-only and requires the \"audit\" query parameter to be retrieved.  The field timeseries requires the \"deep\" query parameter to be retrieved. 
*/
export class VersionedSeries {
    'version': Semver;
    'versionedId': string;
    'versionOwner'?: string;
    'versionStatus': Vstatus;
    'parentVersionedId'?: string;
    'formula'?: string;
    'versionStatusChangeReason'?: Translation;
    'versionTitle'?: Translation;
    'versionDescriptionShort'?: Translation;
    'versionDescriptionLong'?: Translation;
    'timeseries'?: TsValues;
    'auditTrail'?: Audit;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "Semver"
        },
        {
            "name": "versionedId",
            "baseName": "versionedId",
            "type": "string"
        },
        {
            "name": "versionOwner",
            "baseName": "versionOwner",
            "type": "string"
        },
        {
            "name": "versionStatus",
            "baseName": "versionStatus",
            "type": "Vstatus"
        },
        {
            "name": "parentVersionedId",
            "baseName": "parentVersionedId",
            "type": "string"
        },
        {
            "name": "formula",
            "baseName": "formula",
            "type": "string"
        },
        {
            "name": "versionStatusChangeReason",
            "baseName": "versionStatusChangeReason",
            "type": "Translation"
        },
        {
            "name": "versionTitle",
            "baseName": "versionTitle",
            "type": "Translation"
        },
        {
            "name": "versionDescriptionShort",
            "baseName": "versionDescriptionShort",
            "type": "Translation"
        },
        {
            "name": "versionDescriptionLong",
            "baseName": "versionDescriptionLong",
            "type": "Translation"
        },
        {
            "name": "timeseries",
            "baseName": "timeseries",
            "type": "TsValues"
        },
        {
            "name": "auditTrail",
            "baseName": "auditTrail",
            "type": "Audit"
        }    ];

    static getAttributeTypeMap() {
        return VersionedSeries.attributeTypeMap;
    }
}

export class Vstatus {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Vstatus.attributeTypeMap;
    }
}

/**
* Geographical zones. 
*/
export class Zone extends ClassNomenclature {
    'zoneType': Ztype;
    'zoneGeometry'?: Geometry;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "zoneType",
            "baseName": "zoneType",
            "type": "Ztype"
        },
        {
            "name": "zoneGeometry",
            "baseName": "zoneGeometry",
            "type": "Geometry"
        }    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Zone.attributeTypeMap);
    }
}

/**
* Typology of geographical zones (e.g. world, country, ...) 
*/
export class Ztype extends ClassNomenclature {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Ztype.attributeTypeMap);
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "ApiError": ApiError,
    "Audit": Audit,
    "ClassDescription": ClassDescription,
    "ClassMetadata": ClassMetadata,
    "ClassNomenclature": ClassNomenclature,
    "ClassNomenclatureName": ClassNomenclatureName,
    "CompositeUnit": CompositeUnit,
    "Constant": Constant,
    "Conversion": Conversion,
    "ConversionSpec": ConversionSpec,
    "Document": Document,
    "Documents": Documents,
    "Entities": Entities,
    "Extra": Extra,
    "Geometry": Geometry,
    "Mdimension": Mdimension,
    "Mdomain": Mdomain,
    "Measurement": Measurement,
    "Multiplier": Multiplier,
    "Mumeta": Mumeta,
    "Munit": Munit,
    "Musystem": Musystem,
    "Ostatus": Ostatus,
    "Owner": Owner,
    "Period": Period,
    "Role": Role,
    "SearchTags": SearchTags,
    "Semver": Semver,
    "Series": Series,
    "Source": Source,
    "Status": Status,
    "Theme": Theme,
    "TimeseriesModelsYamldefinitionsclassDescription": TimeseriesModelsYamldefinitionsclassDescription,
    "TimeseriesModelsYamldefinitionsclassNomenclature": TimeseriesModelsYamldefinitionsclassNomenclature,
    "TimeseriesModelsYamldefinitionsconversionSpec": TimeseriesModelsYamldefinitionsconversionSpec,
    "TimeseriesModelsYamldefinitionsseries": TimeseriesModelsYamldefinitionsseries,
    "TimeseriesModelsYamldefinitionstsValues": TimeseriesModelsYamldefinitionstsValues,
    "TimeseriesModelsYamldefinitionsversionedSeries": TimeseriesModelsYamldefinitionsversionedSeries,
    "Translation": Translation,
    "Ts": Ts,
    "TsValue": TsValue,
    "TsValues": TsValues,
    "VersionedSeries": VersionedSeries,
    "Vstatus": Vstatus,
    "Zone": Zone,
    "Ztype": Ztype,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ClassesApiApiKeys {
    apiKey,
}

export class ClassesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'X-API-Key'),
        'bearerToken': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClassesApiApiKeys, value: string) {
        (this.authentications as any)[ClassesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.bearerToken.accessToken = token;
    }
    /**
     * 
     * @summary Get metadata about a nomenclature class
     * @param classId The internal name of a nomenclature class.  Valid classes are:   * constant: mathematical and physical constants   * mdimension: base measured dimensions   * mdomain: domains that pertain to measurements   * measurement: physical and economic measurements   * multiplier: unit multipliers aka prefixes (e.g. k,M,G...)   * munit: measurement units   * musystem: systems of measurement units   * ostatus: owner statuses   * owner: series owner   * period: time series periods (e.g. monthly, yearly...)   * role: series owner role   * source: data sources   * status: series and versions statuses   * theme: climate themes   * zone: geographical zones   * ztype: zone types 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public classesClassIdGet (classId: 'constant' | 'mdimension' | 'mdomain' | 'measurement' | 'multiplier' | 'munit' | 'musystem' | 'ostatus' | 'owner' | 'period' | 'role' | 'source' | 'status' | 'theme' | 'zone' | 'ztype', deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ClassDescription;  }> {
        const localVarPath = this.basePath + '/classes/{classId}'
            .replace('{' + 'classId' + '}', encodeURIComponent(String(classId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'classId' is not null or undefined
        if (classId === null || classId === undefined) {
            throw new Error('Required parameter classId was null or undefined when calling classesClassIdGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClassDescription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ClassDescription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a member from a nomenclature class
     * @param classId The internal name of a nomenclature class.  Valid classes are:   * constant: mathematical and physical constants   * mdimension: base measured dimensions   * mdomain: domains that pertain to measurements   * measurement: physical and economic measurements   * multiplier: unit multipliers aka prefixes (e.g. k,M,G...)   * munit: measurement units   * musystem: systems of measurement units   * ostatus: owner statuses   * owner: series owner   * period: time series periods (e.g. monthly, yearly...)   * role: series owner role   * source: data sources   * status: series and versions statuses   * theme: climate themes   * zone: geographical zones   * ztype: zone types 
     * @param classMemberId The unique identifier of a class member. 
     * @param classMember Class member metadata. 
     * @param {*} [options] Override http request options.
     */
    public classesClassIdMembersClassMemberIdDelete (classId: 'constant' | 'mdimension' | 'mdomain' | 'measurement' | 'multiplier' | 'munit' | 'musystem' | 'ostatus' | 'owner' | 'period' | 'role' | 'source' | 'status' | 'theme' | 'zone' | 'ztype', classMemberId: number, classMember: ClassNomenclature, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/classes/{classId}/members/{classMemberId}'
            .replace('{' + 'classId' + '}', encodeURIComponent(String(classId)))
            .replace('{' + 'classMemberId' + '}', encodeURIComponent(String(classMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'classId' is not null or undefined
        if (classId === null || classId === undefined) {
            throw new Error('Required parameter classId was null or undefined when calling classesClassIdMembersClassMemberIdDelete.');
        }

        // verify required parameter 'classMemberId' is not null or undefined
        if (classMemberId === null || classMemberId === undefined) {
            throw new Error('Required parameter classMemberId was null or undefined when calling classesClassIdMembersClassMemberIdDelete.');
        }

        // verify required parameter 'classMember' is not null or undefined
        if (classMember === null || classMember === undefined) {
            throw new Error('Required parameter classMember was null or undefined when calling classesClassIdMembersClassMemberIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(classMember, "ClassNomenclature")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a member of a nomenclature class
     * @param classId The internal name of a nomenclature class.  Valid classes are:   * constant: mathematical and physical constants   * mdimension: base measured dimensions   * mdomain: domains that pertain to measurements   * measurement: physical and economic measurements   * multiplier: unit multipliers aka prefixes (e.g. k,M,G...)   * munit: measurement units   * musystem: systems of measurement units   * ostatus: owner statuses   * owner: series owner   * period: time series periods (e.g. monthly, yearly...)   * role: series owner role   * source: data sources   * status: series and versions statuses   * theme: climate themes   * zone: geographical zones   * ztype: zone types 
     * @param classMemberId The unique identifier of a class member. 
     * @param classMember Class member metadata. 
     * @param {*} [options] Override http request options.
     */
    public classesClassIdMembersClassMemberIdPut (classId: 'constant' | 'mdimension' | 'mdomain' | 'measurement' | 'multiplier' | 'munit' | 'musystem' | 'ostatus' | 'owner' | 'period' | 'role' | 'source' | 'status' | 'theme' | 'zone' | 'ztype', classMemberId: number, classMember: ClassNomenclature, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/classes/{classId}/members/{classMemberId}'
            .replace('{' + 'classId' + '}', encodeURIComponent(String(classId)))
            .replace('{' + 'classMemberId' + '}', encodeURIComponent(String(classMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'classId' is not null or undefined
        if (classId === null || classId === undefined) {
            throw new Error('Required parameter classId was null or undefined when calling classesClassIdMembersClassMemberIdPut.');
        }

        // verify required parameter 'classMemberId' is not null or undefined
        if (classMemberId === null || classMemberId === undefined) {
            throw new Error('Required parameter classMemberId was null or undefined when calling classesClassIdMembersClassMemberIdPut.');
        }

        // verify required parameter 'classMember' is not null or undefined
        if (classMember === null || classMember === undefined) {
            throw new Error('Required parameter classMember was null or undefined when calling classesClassIdMembersClassMemberIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(classMember, "ClassNomenclature")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a a collection of nomenclature class members.  Example:   GET /classes/munit/members returns all measurement units.  If the request negotiates a response MIME type with text/csv (with the Accept header), this endpoint produces a CSV file. 
     * @summary Get all the members of a nomenclature class
     * @param classId The internal name of a nomenclature class.  Valid classes are:   * constant: mathematical and physical constants   * mdimension: base measured dimensions   * mdomain: domains that pertain to measurements   * measurement: physical and economic measurements   * multiplier: unit multipliers aka prefixes (e.g. k,M,G...)   * munit: measurement units   * musystem: systems of measurement units   * ostatus: owner statuses   * owner: series owner   * period: time series periods (e.g. monthly, yearly...)   * role: series owner role   * source: data sources   * status: series and versions statuses   * theme: climate themes   * zone: geographical zones   * ztype: zone types 
     * @param glob Filters the result according to a glob pattern applied on the short name of the requested object. 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param tag Filter the result by search for a given keyword, whenever tag search is applicable.  This parameter has no effect on objects where tag search is not applicable. 
     * @param tags Filter the result by search for one tag in the given list of keywords, whenever tag search is applicable.  Up to 5 tags can be searched.  This parameter has no effect on objects where tag search is not applicable. 
     * @param {*} [options] Override http request options.
     */
    public classesClassIdMembersGet (classId: 'constant' | 'mdimension' | 'mdomain' | 'measurement' | 'multiplier' | 'munit' | 'musystem' | 'ostatus' | 'owner' | 'period' | 'role' | 'source' | 'status' | 'theme' | 'zone' | 'ztype', glob?: string, deep?: boolean, brief?: boolean, audit?: boolean, tag?: string, tags?: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ClassNomenclature>;  }> {
        const localVarPath = this.basePath + '/classes/{classId}/members'
            .replace('{' + 'classId' + '}', encodeURIComponent(String(classId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'classId' is not null or undefined
        if (classId === null || classId === undefined) {
            throw new Error('Required parameter classId was null or undefined when calling classesClassIdMembersGet.');
        }

        if (glob !== undefined) {
            localVarQueryParameters['glob'] = ObjectSerializer.serialize(glob, "string");
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ClassNomenclature>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ClassNomenclature>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new member in a nomenclature class
     * @param classId The internal name of a nomenclature class.  Valid classes are:   * constant: mathematical and physical constants   * mdimension: base measured dimensions   * mdomain: domains that pertain to measurements   * measurement: physical and economic measurements   * multiplier: unit multipliers aka prefixes (e.g. k,M,G...)   * munit: measurement units   * musystem: systems of measurement units   * ostatus: owner statuses   * owner: series owner   * period: time series periods (e.g. monthly, yearly...)   * role: series owner role   * source: data sources   * status: series and versions statuses   * theme: climate themes   * zone: geographical zones   * ztype: zone types 
     * @param classMember Class member metadata. 
     * @param {*} [options] Override http request options.
     */
    public classesClassIdMembersPost (classId: 'constant' | 'mdimension' | 'mdomain' | 'measurement' | 'multiplier' | 'munit' | 'musystem' | 'ostatus' | 'owner' | 'period' | 'role' | 'source' | 'status' | 'theme' | 'zone' | 'ztype', classMember: ClassNomenclature, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/classes/{classId}/members'
            .replace('{' + 'classId' + '}', encodeURIComponent(String(classId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'classId' is not null or undefined
        if (classId === null || classId === undefined) {
            throw new Error('Required parameter classId was null or undefined when calling classesClassIdMembersPost.');
        }

        // verify required parameter 'classMember' is not null or undefined
        if (classMember === null || classMember === undefined) {
            throw new Error('Required parameter classMember was null or undefined when calling classesClassIdMembersPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(classMember, "ClassNomenclature")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update descriptive metadata about a nomenclature class
     * @param classId The internal name of a nomenclature class.  Valid classes are:   * constant: mathematical and physical constants   * mdimension: base measured dimensions   * mdomain: domains that pertain to measurements   * measurement: physical and economic measurements   * multiplier: unit multipliers aka prefixes (e.g. k,M,G...)   * munit: measurement units   * musystem: systems of measurement units   * ostatus: owner statuses   * owner: series owner   * period: time series periods (e.g. monthly, yearly...)   * role: series owner role   * source: data sources   * status: series and versions statuses   * theme: climate themes   * zone: geographical zones   * ztype: zone types 
     * @param classDescription Class descriptive metadata. 
     * @param {*} [options] Override http request options.
     */
    public classesClassIdPut (classId: 'constant' | 'mdimension' | 'mdomain' | 'measurement' | 'multiplier' | 'munit' | 'musystem' | 'ostatus' | 'owner' | 'period' | 'role' | 'source' | 'status' | 'theme' | 'zone' | 'ztype', classDescription: ClassDescription, options: any = {}) : Promise<{ response: http.ClientResponse; body: ClassDescription;  }> {
        const localVarPath = this.basePath + '/classes/{classId}'
            .replace('{' + 'classId' + '}', encodeURIComponent(String(classId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'classId' is not null or undefined
        if (classId === null || classId === undefined) {
            throw new Error('Required parameter classId was null or undefined when calling classesClassIdPut.');
        }

        // verify required parameter 'classDescription' is not null or undefined
        if (classDescription === null || classDescription === undefined) {
            throw new Error('Required parameter classDescription was null or undefined when calling classesClassIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(classDescription, "ClassDescription")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ClassDescription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ClassDescription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all valid nomenclature classes
     * @param glob Filters the result according to a glob pattern applied on the short name of the requested object. 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public classesGet (glob?: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ClassNomenclature>;  }> {
        const localVarPath = this.basePath + '/classes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (glob !== undefined) {
            localVarQueryParameters['glob'] = ObjectSerializer.serialize(glob, "string");
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ClassNomenclature>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ClassNomenclature>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConversionsApiApiKeys {
    apiKey,
}

export class ConversionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'X-API-Key'),
        'bearerToken': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConversionsApiApiKeys, value: string) {
        (this.authentications as any)[ConversionsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.bearerToken.accessToken = token;
    }
    /**
     * 
     * @summary Get the conversion specification from unit to unit.
     * @param fromUnit Original unit to be converted. 
     * @param toUnit Original unit to be converted. 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public conversionFromUnitToUnitGet (fromUnit: string, toUnit: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ConversionSpec;  }> {
        const localVarPath = this.basePath + '/conversion/{fromUnit}/{toUnit}'
            .replace('{' + 'fromUnit' + '}', encodeURIComponent(String(fromUnit)))
            .replace('{' + 'toUnit' + '}', encodeURIComponent(String(toUnit)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromUnit' is not null or undefined
        if (fromUnit === null || fromUnit === undefined) {
            throw new Error('Required parameter fromUnit was null or undefined when calling conversionFromUnitToUnitGet.');
        }

        // verify required parameter 'toUnit' is not null or undefined
        if (toUnit === null || toUnit === undefined) {
            throw new Error('Required parameter toUnit was null or undefined when calling conversionFromUnitToUnitGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ConversionSpec;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConversionSpec");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the conversion specification from unit to unit.
     * @param fromUnit Original unit to be converted. 
     * @param toUnit Target unit result of the conversion. 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public conversionGet (fromUnit?: string, toUnit?: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Conversion;  }> {
        const localVarPath = this.basePath + '/conversion';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (fromUnit !== undefined) {
            localVarQueryParameters['fromUnit'] = ObjectSerializer.serialize(fromUnit, "string");
        }

        if (toUnit !== undefined) {
            localVarQueryParameters['toUnit'] = ObjectSerializer.serialize(toUnit, "string");
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Conversion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Conversion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing conversion specification from unit to unit.
     * @param fromUnit Original unit to be converted. 
     * @param toUnit Original unit to be converted. 
     * @param {*} [options] Override http request options.
     */
    public conversionsFromUnitToUnitDelete (fromUnit: string, toUnit: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/conversions/{fromUnit}/{toUnit}'
            .replace('{' + 'fromUnit' + '}', encodeURIComponent(String(fromUnit)))
            .replace('{' + 'toUnit' + '}', encodeURIComponent(String(toUnit)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromUnit' is not null or undefined
        if (fromUnit === null || fromUnit === undefined) {
            throw new Error('Required parameter fromUnit was null or undefined when calling conversionsFromUnitToUnitDelete.');
        }

        // verify required parameter 'toUnit' is not null or undefined
        if (toUnit === null || toUnit === undefined) {
            throw new Error('Required parameter toUnit was null or undefined when calling conversionsFromUnitToUnitDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates add new conversion specification from unit to unit.
     * @param fromUnit Original unit to be converted. 
     * @param toUnit Original unit to be converted. 
     * @param conversionSpec Unit conversion specification. 
     * @param {*} [options] Override http request options.
     */
    public conversionsFromUnitToUnitPost (fromUnit: string, toUnit: string, conversionSpec: ConversionSpec, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/conversions/{fromUnit}/{toUnit}'
            .replace('{' + 'fromUnit' + '}', encodeURIComponent(String(fromUnit)))
            .replace('{' + 'toUnit' + '}', encodeURIComponent(String(toUnit)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromUnit' is not null or undefined
        if (fromUnit === null || fromUnit === undefined) {
            throw new Error('Required parameter fromUnit was null or undefined when calling conversionsFromUnitToUnitPost.');
        }

        // verify required parameter 'toUnit' is not null or undefined
        if (toUnit === null || toUnit === undefined) {
            throw new Error('Required parameter toUnit was null or undefined when calling conversionsFromUnitToUnitPost.');
        }

        // verify required parameter 'conversionSpec' is not null or undefined
        if (conversionSpec === null || conversionSpec === undefined) {
            throw new Error('Required parameter conversionSpec was null or undefined when calling conversionsFromUnitToUnitPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(conversionSpec, "ConversionSpec")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing conversion specification from unit to unit.
     * @param fromUnit Original unit to be converted. 
     * @param toUnit Original unit to be converted. 
     * @param conversionSpec Unit conversion specification. 
     * @param {*} [options] Override http request options.
     */
    public conversionsFromUnitToUnitPut (fromUnit: string, toUnit: string, conversionSpec: ConversionSpec, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/conversions/{fromUnit}/{toUnit}'
            .replace('{' + 'fromUnit' + '}', encodeURIComponent(String(fromUnit)))
            .replace('{' + 'toUnit' + '}', encodeURIComponent(String(toUnit)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fromUnit' is not null or undefined
        if (fromUnit === null || fromUnit === undefined) {
            throw new Error('Required parameter fromUnit was null or undefined when calling conversionsFromUnitToUnitPut.');
        }

        // verify required parameter 'toUnit' is not null or undefined
        if (toUnit === null || toUnit === undefined) {
            throw new Error('Required parameter toUnit was null or undefined when calling conversionsFromUnitToUnitPut.');
        }

        // verify required parameter 'conversionSpec' is not null or undefined
        if (conversionSpec === null || conversionSpec === undefined) {
            throw new Error('Required parameter conversionSpec was null or undefined when calling conversionsFromUnitToUnitPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(conversionSpec, "ConversionSpec")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.bearerToken.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List available unit conversions, with some query filters
     * @param fromUnit Original unit to be converted. 
     * @param toUnit Target unit result of the conversion. 
     * @param {*} [options] Override http request options.
     */
    public conversionsGet (fromUnit?: string, toUnit?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Conversion>;  }> {
        const localVarPath = this.basePath + '/conversions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (fromUnit !== undefined) {
            localVarQueryParameters['fromUnit'] = ObjectSerializer.serialize(fromUnit, "string");
        }

        if (toUnit !== undefined) {
            localVarQueryParameters['toUnit'] = ObjectSerializer.serialize(toUnit, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Conversion>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Conversion>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SemverApiApiKeys {
    apiKey,
}

export class SemverApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'X-API-Key'),
        'bearerToken': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SemverApiApiKeys, value: string) {
        (this.authentications as any)[SemverApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.bearerToken.accessToken = token;
    }
    /**
     * 
     * @summary Get all semver tags associated to a series
     * @param seriesId The unique ID of a time series.
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdSemverGet (seriesId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/semver'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdSemverGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Semver tags follow semantic versioning rules (e.g. v1.2.3, v1.2.3-rc1, v1.3.0 ...).  Unless requested by the query parameters, the time series values are not returned by default. 
     * @summary Get a version of a time series with a semver tag
     * @param seriesId The unique ID of a time series.
     * @param semver The semver tag of a series&#39; version.
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdSemverSemverGet (seriesId: number, semver: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: VersionedSeries;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/semver/{semver}'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)))
            .replace('{' + 'semver' + '}', encodeURIComponent(String(semver)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdSemverSemverGet.');
        }

        // verify required parameter 'semver' is not null or undefined
        if (semver === null || semver === undefined) {
            throw new Error('Required parameter semver was null or undefined when calling seriesSeriesIdSemverSemverGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VersionedSeries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VersionedSeries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *  If the request negotiates a response MIME type with text/csv (with the Accept header), this endpoint produces a CSV file. 
     * @summary Get the values of version of a time series with a semver tag
     * @param seriesId The unique ID of a time series.
     * @param semver The semver tag of a series&#39; version.
     * @param from Truncates values starting from this date (boundary is included). 
     * @param to Truncates values up to this date (boundary is included). 
     * @param convert Converts values in some other compatible measurement unit, possibly specified as a composite measurement unit. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdSemverSemverValuesGet (seriesId: number, semver: string, from?: Date, to?: Date, convert?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TsValues;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/semver/{semver}/values'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)))
            .replace('{' + 'semver' + '}', encodeURIComponent(String(semver)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdSemverSemverValuesGet.');
        }

        // verify required parameter 'semver' is not null or undefined
        if (semver === null || semver === undefined) {
            throw new Error('Required parameter semver was null or undefined when calling seriesSeriesIdSemverSemverValuesGet.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (convert !== undefined) {
            localVarQueryParameters['convert'] = ObjectSerializer.serialize(convert, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TsValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TsValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SeriesApiApiKeys {
    apiKey,
}

export class SeriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'X-API-Key'),
        'bearerToken': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SeriesApiApiKeys, value: string) {
        (this.authentications as any)[SeriesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.bearerToken.accessToken = token;
    }
    /**
     * 
     * @summary Get all available series, with search filters
     * @param glob Filters the result according to a glob pattern applied on the short name of the requested object. 
     * @param tag Filter the result by search for a given keyword, whenever tag search is applicable.  This parameter has no effect on objects where tag search is not applicable. 
     * @param tags Filter the result by search for one tag in the given list of keywords, whenever tag search is applicable.  Up to 5 tags can be searched.  This parameter has no effect on objects where tag search is not applicable. 
     * @param theme A theme path (url-encoded) to be searched for. 
     * @param zone A zone short code (url-encoded) to be searched for. 
     * @param status Filter the result according to a given status.  Only series in the \&quot;PUBLISHED\&quot; status are returned to the public.  Series owner may consult their series in any status. 
     * @param ownerId The ID of the contributor. 
     * @param datasource A datasource short code to be searched for. 
     * @param email Refers to some data owner by email. 
     * @param {*} [options] Override http request options.
     */
    public seriesGet (glob?: string, tag?: string, tags?: Array<string>, theme?: string, zone?: string, status?: 'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP', ownerId?: string, datasource?: string, email?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Series>;  }> {
        const localVarPath = this.basePath + '/series';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (glob !== undefined) {
            localVarQueryParameters['glob'] = ObjectSerializer.serialize(glob, "string");
        }

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "Array<string>");
        }

        if (theme !== undefined) {
            localVarQueryParameters['theme'] = ObjectSerializer.serialize(theme, "string");
        }

        if (zone !== undefined) {
            localVarQueryParameters['zone'] = ObjectSerializer.serialize(zone, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP'");
        }

        if (ownerId !== undefined) {
            localVarQueryParameters['ownerId'] = ObjectSerializer.serialize(ownerId, "string");
        }

        if (datasource !== undefined) {
            localVarQueryParameters['datasource'] = ObjectSerializer.serialize(datasource, "string");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Series>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Series>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This creates a new time time series.  If some values are specified, the initial version for the new series is created with these values. 
     * @summary Creates a new time series
     * @param series The description of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesPost (series: Series, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'series' is not null or undefined
        if (series === null || series === undefined) {
            throw new Error('Required parameter series was null or undefined when calling seriesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(series, "Series")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * All versions and values associated to this series are deleted.  Only the original owner of a series may delete it. 
     * @summary Deletes a time series
     * @param seriesId The unique ID of a time series.
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdDelete (seriesId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all versions of a time series.
     * @param seriesId The unique ID of a time series.
     * @param glob Filters the result according to a glob pattern applied on the short name of the requested object. 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param status Filter the result according to a given status.  Only series in the \&quot;PUBLISHED\&quot; status are returned to the public.  Series owner may consult their series in any status. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdGet (seriesId: number, glob?: string, deep?: boolean, brief?: boolean, audit?: boolean, status?: 'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP', options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<VersionedSeries>;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdGet.');
        }

        if (glob !== undefined) {
            localVarQueryParameters['glob'] = ObjectSerializer.serialize(glob, "string");
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<VersionedSeries>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<VersionedSeries>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The latest version is determined according to semantic versioning rules (e.g. v1.2.3 < v1.2.4).  Unless requested by the query parameters, the time series values are not returned by default. 
     * @summary Get the latest version of the description of a time series
     * @param seriesId The unique ID of a time series.
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param status Filter the result according to a given status.  Only series in the \&quot;PUBLISHED\&quot; status are returned to the public.  Series owner may consult their series in any status. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdLatestGet (seriesId: number, deep?: boolean, brief?: boolean, audit?: boolean, status?: 'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP', options: any = {}) : Promise<{ response: http.ClientResponse; body: VersionedSeries;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/latest'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdLatestGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VersionedSeries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VersionedSeries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The latest version is determined according to semantic versioning rules (e.g. v1.2.3 < v1.2.4).  Values are returned in chronological order.  If the request negotiates a response MIME type with text/csv (with the Accept header), this endpoint produces a CSV file. 
     * @summary Get the values from the latest version of a time series
     * @param seriesId The unique ID of a time series.
     * @param from Truncates values starting from this date (boundary is included). 
     * @param to Truncates values up to this date (boundary is included). 
     * @param convert Converts values in some other compatible measurement unit, possibly specified as a composite measurement unit. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdLatestValuesGet (seriesId: number, from?: Date, to?: Date, convert?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TsValues;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/latest/values'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdLatestValuesGet.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (convert !== undefined) {
            localVarQueryParameters['convert'] = ObjectSerializer.serialize(convert, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TsValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TsValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new version of a time series
     * @param seriesId The unique ID of a time series.
     * @param series The description of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdPost (seriesId: number, series: Series, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdPost.');
        }

        // verify required parameter 'series' is not null or undefined
        if (series === null || series === undefined) {
            throw new Error('Required parameter series was null or undefined when calling seriesSeriesIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(series, "Series")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This action only updates metadata about the series (such as associated themes, tags, etc) and does not create a new version.  Only owners registered for a series may update the series.  Any time series values specified in the input are ignored. One must update a specific version to modify the values of a time series. 
     * @summary Updates metadata about a time series
     * @param seriesId The unique ID of a time series.
     * @param series The description of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdPut (seriesId: number, series: Series, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdPut.');
        }

        // verify required parameter 'series' is not null or undefined
        if (series === null || series === undefined) {
            throw new Error('Required parameter series was null or undefined when calling seriesSeriesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(series, "Series")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all semver tags associated to a series
     * @param seriesId The unique ID of a time series.
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdSemverGet (seriesId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/semver'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdSemverGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Semver tags follow semantic versioning rules (e.g. v1.2.3, v1.2.3-rc1, v1.3.0 ...).  Unless requested by the query parameters, the time series values are not returned by default. 
     * @summary Get a version of a time series with a semver tag
     * @param seriesId The unique ID of a time series.
     * @param semver The semver tag of a series&#39; version.
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdSemverSemverGet (seriesId: number, semver: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: VersionedSeries;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/semver/{semver}'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)))
            .replace('{' + 'semver' + '}', encodeURIComponent(String(semver)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdSemverSemverGet.');
        }

        // verify required parameter 'semver' is not null or undefined
        if (semver === null || semver === undefined) {
            throw new Error('Required parameter semver was null or undefined when calling seriesSeriesIdSemverSemverGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VersionedSeries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VersionedSeries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *  If the request negotiates a response MIME type with text/csv (with the Accept header), this endpoint produces a CSV file. 
     * @summary Get the values of version of a time series with a semver tag
     * @param seriesId The unique ID of a time series.
     * @param semver The semver tag of a series&#39; version.
     * @param from Truncates values starting from this date (boundary is included). 
     * @param to Truncates values up to this date (boundary is included). 
     * @param convert Converts values in some other compatible measurement unit, possibly specified as a composite measurement unit. 
     * @param {*} [options] Override http request options.
     */
    public seriesSeriesIdSemverSemverValuesGet (seriesId: number, semver: string, from?: Date, to?: Date, convert?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TsValues;  }> {
        const localVarPath = this.basePath + '/series/{seriesId}/semver/{semver}/values'
            .replace('{' + 'seriesId' + '}', encodeURIComponent(String(seriesId)))
            .replace('{' + 'semver' + '}', encodeURIComponent(String(semver)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'seriesId' is not null or undefined
        if (seriesId === null || seriesId === undefined) {
            throw new Error('Required parameter seriesId was null or undefined when calling seriesSeriesIdSemverSemverValuesGet.');
        }

        // verify required parameter 'semver' is not null or undefined
        if (semver === null || semver === undefined) {
            throw new Error('Required parameter semver was null or undefined when calling seriesSeriesIdSemverSemverValuesGet.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (convert !== undefined) {
            localVarQueryParameters['convert'] = ObjectSerializer.serialize(convert, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TsValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TsValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only the original owner of this version of the series may delete it.  All values associated to that version are deleted. 
     * @summary Deletes a version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdDelete (versionedSeriesId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unless requested by the query parameters, the time series values are not returned by default. 
     * @summary Get a version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdGet (versionedSeriesId: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: VersionedSeries;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VersionedSeries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VersionedSeries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A conflict is reported if the version was already attributed to a version of the same series. Use PUT to update existing values. 
     * @summary creates a new version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param versionSeries The description of a version of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdPost (versionedSeriesId: string, versionSeries: VersionedSeries, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdPost.');
        }

        // verify required parameter 'versionSeries' is not null or undefined
        if (versionSeries === null || versionSeries === undefined) {
            throw new Error('Required parameter versionSeries was null or undefined when calling seriesVersionsVersionedSeriesIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(versionSeries, "VersionedSeries")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint replaces the metadata for the requested version, without creating a new version.  Only the owners of the time series may modify values. 
     * @summary Updates the metadata of version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param versionSeries The description of a version of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdPut (versionedSeriesId: string, versionSeries: VersionedSeries, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdPut.');
        }

        // verify required parameter 'versionSeries' is not null or undefined
        if (versionSeries === null || versionSeries === undefined) {
            throw new Error('Required parameter versionSeries was null or undefined when calling seriesVersionsVersionedSeriesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(versionSeries, "VersionedSeries")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only the original owner of this version of the series may delete it.  The version is not deleted. Only the values associated to that version are deleted. 
     * @summary Deletes the values attached to a version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesDelete (versionedSeriesId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If the request negotiates a response MIME type with text/csv (with the Accept header), this endpoint produces a CSV file. 
     * @summary Get the values of version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param from Truncates values starting from this date (boundary is included). 
     * @param to Truncates values up to this date (boundary is included). 
     * @param convert Converts values in some other compatible measurement unit, possibly specified as a composite measurement unit. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesGet (versionedSeriesId: string, from?: Date, to?: Date, convert?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TsValues;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesGet.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (convert !== undefined) {
            localVarQueryParameters['convert'] = ObjectSerializer.serialize(convert, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TsValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TsValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint creates time series values for the latest version.  Only the owners of the time series may add values.  A conflict is reported if values were already attributed to this version. Use PUT to update existing values.  If the request negotiates a request MIME type with text/csv (with the Content-Type header), this endpoint consumes a CSV file. 
     * @summary Uploads values to the version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param values The values of a time series 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesPost (versionedSeriesId: string, values: TsValues, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPost.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(values, "TsValues")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint replaces time series values for the requested version, without creating a new version.  Only the owners of the time series may modify values.  A conflict is reported if values were already attributed to this version. Use PUT to update existing values.  If the request negotiates a request MIME type with text/csv (with the Content-Type header), this endpoint consumes a CSV file. 
     * @summary Replaces the values of version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param values The values of a time series 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesPut (versionedSeriesId: string, values: TsValues, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPut.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(values, "TsValues")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TagsApiApiKeys {
    apiKey,
}

export class TagsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'X-API-Key'),
        'bearerToken': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TagsApiApiKeys, value: string) {
        (this.authentications as any)[TagsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.bearerToken.accessToken = token;
    }
    /**
     * 
     * @summary List all known tags
     * @param {*} [options] Override http request options.
     */
    public searchTagsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/search/tags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint returns mulitple entities, such as classes or series. 
     * @summary Search all entities with some tag
     * @param tag Filter the result by search for a given keyword, whenever tag search is applicable.  This parameter has no effect on objects where tag search is not applicable. 
     * @param status Filter the result according to a given status.  Only series in the \&quot;PUBLISHED\&quot; status are returned to the public.  Series owner may consult their series in any status. 
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param ownerId The ID of the contributor. 
     * @param email Refers to some data owner by email. 
     * @param {*} [options] Override http request options.
     */
    public searchTagsTagGet (tag: string, status?: 'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP', deep?: boolean, brief?: boolean, audit?: boolean, ownerId?: string, email?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Entities;  }> {
        const localVarPath = this.basePath + '/search/tags/{tag}'
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling searchTagsTagGet.');
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'VALIDATED' | 'PUBLISHED' | 'REJECTED' | 'PENDINGV' | 'PENDINGP'");
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        if (ownerId !== undefined) {
            localVarQueryParameters['ownerId'] = ObjectSerializer.serialize(ownerId, "string");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Entities;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Entities");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VersioningApiApiKeys {
    apiKey,
}

export class VersioningApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'X-API-Key'),
        'bearerToken': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VersioningApiApiKeys, value: string) {
        (this.authentications as any)[VersioningApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.bearerToken.accessToken = token;
    }
    /**
     * Only the original owner of this version of the series may delete it.  All values associated to that version are deleted. 
     * @summary Deletes a version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdDelete (versionedSeriesId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unless requested by the query parameters, the time series values are not returned by default. 
     * @summary Get a version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param deep When deep is specified, the response will contain a deep representation of the object, rather than just a shallow description. 
     * @param brief When brief is specified, the response will only contain essential data and strip long descriptions. 
     * @param audit When audit is specified, the response will also contain the audit trail field. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdGet (versionedSeriesId: string, deep?: boolean, brief?: boolean, audit?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: VersionedSeries;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdGet.');
        }

        if (deep !== undefined) {
            localVarQueryParameters['deep'] = ObjectSerializer.serialize(deep, "boolean");
        }

        if (brief !== undefined) {
            localVarQueryParameters['brief'] = ObjectSerializer.serialize(brief, "boolean");
        }

        if (audit !== undefined) {
            localVarQueryParameters['audit'] = ObjectSerializer.serialize(audit, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VersionedSeries;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VersionedSeries");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A conflict is reported if the version was already attributed to a version of the same series. Use PUT to update existing values. 
     * @summary creates a new version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param versionSeries The description of a version of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdPost (versionedSeriesId: string, versionSeries: VersionedSeries, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdPost.');
        }

        // verify required parameter 'versionSeries' is not null or undefined
        if (versionSeries === null || versionSeries === undefined) {
            throw new Error('Required parameter versionSeries was null or undefined when calling seriesVersionsVersionedSeriesIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(versionSeries, "VersionedSeries")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint replaces the metadata for the requested version, without creating a new version.  Only the owners of the time series may modify values. 
     * @summary Updates the metadata of version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param versionSeries The description of a version of a time series. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdPut (versionedSeriesId: string, versionSeries: VersionedSeries, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdPut.');
        }

        // verify required parameter 'versionSeries' is not null or undefined
        if (versionSeries === null || versionSeries === undefined) {
            throw new Error('Required parameter versionSeries was null or undefined when calling seriesVersionsVersionedSeriesIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(versionSeries, "VersionedSeries")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only the original owner of this version of the series may delete it.  The version is not deleted. Only the values associated to that version are deleted. 
     * @summary Deletes the values attached to a version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesDelete (versionedSeriesId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If the request negotiates a response MIME type with text/csv (with the Accept header), this endpoint produces a CSV file. 
     * @summary Get the values of version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param from Truncates values starting from this date (boundary is included). 
     * @param to Truncates values up to this date (boundary is included). 
     * @param convert Converts values in some other compatible measurement unit, possibly specified as a composite measurement unit. 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesGet (versionedSeriesId: string, from?: Date, to?: Date, convert?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TsValues;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesGet.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (convert !== undefined) {
            localVarQueryParameters['convert'] = ObjectSerializer.serialize(convert, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TsValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TsValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint creates time series values for the latest version.  Only the owners of the time series may add values.  A conflict is reported if values were already attributed to this version. Use PUT to update existing values.  If the request negotiates a request MIME type with text/csv (with the Content-Type header), this endpoint consumes a CSV file. 
     * @summary Uploads values to the version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param values The values of a time series 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesPost (versionedSeriesId: string, values: TsValues, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPost.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(values, "TsValues")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint replaces time series values for the requested version, without creating a new version.  Only the owners of the time series may modify values.  A conflict is reported if values were already attributed to this version. Use PUT to update existing values.  If the request negotiates a request MIME type with text/csv (with the Content-Type header), this endpoint consumes a CSV file. 
     * @summary Replaces the values of version of a time series
     * @param versionedSeriesId The UUID of a version of the time series.
     * @param values The values of a time series 
     * @param {*} [options] Override http request options.
     */
    public seriesVersionsVersionedSeriesIdValuesPut (versionedSeriesId: string, values: TsValues, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/series/versions/{versionedSeriesId}/values'
            .replace('{' + 'versionedSeriesId' + '}', encodeURIComponent(String(versionedSeriesId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'versionedSeriesId' is not null or undefined
        if (versionedSeriesId === null || versionedSeriesId === undefined) {
            throw new Error('Required parameter versionedSeriesId was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPut.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling seriesVersionsVersionedSeriesIdValuesPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(values, "TsValues")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
